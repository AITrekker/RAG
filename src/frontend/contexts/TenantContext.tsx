/**
 * CRITICAL: Tenant Context API Key Management
 * 
 * This context manages TWO SEPARATE types of API keys:
 * 
 * 1. ADMIN API KEY:
 *    - Purpose: ONLY for loading the tenant list via /admin/tenants endpoint
 *    - Source: /demo_admin_keys.json file (generated by init container)
 *    - Scope: System-wide admin operations only
 *    - DO NOT use for tenant-specific operations!
 * 
 * 2. TENANT API KEY:
 *    - Purpose: ALL tenant-specific operations after tenant selection
 *    - Source: /demo_tenant_keys.json file (tenant-specific keys)
 *    - Scope: Operations within the selected tenant context
 *    - Changes when user switches tenants from dropdown
 * 
 * IMPORTANT: Never mix these keys! Admin key is ONLY for tenant list loading.
 * All other operations must use the selected tenant's specific API key.
 */

import { createContext, useContext, useState, useEffect, useCallback, type ReactNode } from 'react';
import { useQuery, useQueryClient } from '@tanstack/react-query';
import { OpenAPI } from '@/src/services/api.generated/core/OpenAPI';
import { TenantsService } from '@/src/services/api.generated/services/TenantsService';
import type { TenantResponse } from '@/src/services/api.generated/models/TenantResponse';
import type { ApiError } from '@/src/services/api.generated/core/ApiError';

// Set the base URL for the API client
OpenAPI.BASE = "http://localhost:8000";

interface TenantKeyStore {
  [tenantId: string]: {
    api_key: string;
    slug: string;
    description: string;
  };
}

interface TenantContextType {
  tenant: string | null;
  tenants: TenantResponse[];
  selectTenant: (tenantId: string) => void;
  tenantApiKey: string | null;  // Renamed for clarity - this is for tenant operations
  setTenantApiKey: (key: string) => void;
  isLoading: boolean;
  tenantKeys: TenantKeyStore;
}

const TenantContext = createContext<TenantContextType | undefined>(undefined);

export const TenantProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [tenant, setTenant] = useState<string | null>(() => localStorage.getItem('tenantId'));
  
  /**
   * Load tenant-specific API keys from demo_tenant_keys.json
   * These keys are used for ALL operations after a tenant is selected
   */
  const loadTenantKeys = useCallback(async (): Promise<TenantKeyStore> => {
    try {
      const response = await fetch('/demo_tenant_keys.json');
      if (!response.ok) {
        throw new Error('Failed to load tenant keys');
      }
      return await response.json();
    } catch (error) {
      console.error('Error loading tenant keys:', error);
      return {};
    }
  }, []);

  /**
   * Load admin API key from demo_admin_keys.json
   * This key is ONLY used for loading the tenant list via /admin/tenants
   * DO NOT use this key for tenant-specific operations!
   */
  const loadAdminKey = useCallback(async (): Promise<string | null> => {
    try {
      const response = await fetch('/demo_admin_keys.json');
      if (!response.ok) {
        throw new Error('Failed to load admin keys');
      }
      const adminConfig = await response.json();
      return adminConfig.admin_api_key || null;
    } catch (error) {
      console.error('Error loading admin keys:', error);
      return null;
    }
  }, []);

  // State management for keys and data
  const [tenantKeys, setTenantKeys] = useState<TenantKeyStore>({});
  const [adminApiKey, setAdminApiKey] = useState<string | null>(null);  // ONLY for tenant list
  const [tenantApiKey, setTenantApiKey] = useState<string | null>(null); // For tenant operations
  const queryClient = useQueryClient();
  
  /**
   * Load keys on mount and set up initial tenant selection
   * CRITICAL: Admin key is NEVER used as the tenant API key
   */
  useEffect(() => {
    Promise.all([loadTenantKeys(), loadAdminKey()]).then(([keys, adminKey]) => {
      setTenantKeys(keys);
      setAdminApiKey(adminKey); // Store admin key separately
      
      // If we have a selected tenant, set its specific API key
      const currentTenant = localStorage.getItem('tenantId');
      if (currentTenant && keys[currentTenant]) {
        const tenantKey = keys[currentTenant].api_key;
        setTenantApiKey(tenantKey);
        OpenAPI.HEADERS = { 'X-API-Key': tenantKey };
        console.log(`ðŸ”‘ Loaded tenant API key for: ${keys[currentTenant].slug}`);
      } else {
        // No tenant selected - tenant API key remains null
        // DO NOT set admin key as tenant key!
        setTenantApiKey(null);
        OpenAPI.HEADERS = {};
        console.log('ðŸ”‘ No tenant selected, tenant API key is null');
      }
    });
  }, [loadTenantKeys, loadAdminKey]);

  /**
   * Tenant list query - CRITICAL: Uses admin API key ONLY
   * This query loads the list of available tenants using the admin endpoint
   * DO NOT change this to use tenant API key!
   */
  const { data: tenants = [], isLoading } = useQuery<TenantResponse[], ApiError>({
    queryKey: ['tenants'],
    queryFn: async () => {
      if (!adminApiKey) {
        throw new Error('Admin API key not available');
      }
      
      // Use admin endpoint with admin API key - DO NOT change this!
      const response = await fetch(`${OpenAPI.BASE}/api/v1/admin/tenants`, {
        headers: {
          'X-API-Key': adminApiKey,  // ADMIN key only!
          'Content-Type': 'application/json',
        },
      });
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }
      
      const result = await response.json();
      console.log(`ðŸ¢ Loaded ${result.total || 0} tenants using admin API key`);
      
      // The admin endpoint returns {tenants: [...], total: N}
      return result.tenants || [];
    },
    enabled: !!adminApiKey, // Only run when admin API key is available
  });

  /**
   * Select tenant and switch to its API key
   * CRITICAL: This function MUST switch the tenant API key for all subsequent operations
   * The admin API key is NEVER affected by tenant selection
   */
  const selectTenant = useCallback((tenantId: string) => {
    console.log(`ðŸŽ¯ Selecting tenant: ${tenantId}`);
    
    setTenant(tenantId);
    localStorage.setItem('tenantId', tenantId);
    
    // CRITICAL: Switch to the selected tenant's API key for all operations
    const tenantKey = tenantKeys[tenantId];
    if (tenantKey) {
      const newTenantApiKey = tenantKey.api_key;
      setTenantApiKey(newTenantApiKey);
      OpenAPI.HEADERS = { 'X-API-Key': newTenantApiKey };
      console.log(`ðŸ”‘ Switched to tenant API key for: ${tenantKey.slug}`);
    } else {
      console.warn(`âŒ No API key found for tenant: ${tenantId}`);
      setTenantApiKey(null);
      OpenAPI.HEADERS = {};
    }
  }, [tenantKeys]);

  /**
   * Manual tenant API key setter for external use
   * CRITICAL: This only affects tenant operations, not admin operations
   */
  const handleSetTenantApiKey = useCallback((key: string) => {
    setTenantApiKey(key);
    console.log('ðŸ”‘ Manually set tenant API key');
  }, []);

  /**
   * Auto-select first non-admin tenant when tenants load
   * CRITICAL: Only auto-select if no tenant is currently selected
   */
  useEffect(() => {
    if (tenants.length > 0 && !tenant && Object.keys(tenantKeys).length > 0) {
      // Find first non-admin tenant
      const nonAdminTenants = tenants.filter(t => t.name !== 'admin' && t.slug !== 'admin');
      
      if (nonAdminTenants.length > 0) {
        const firstTenant = nonAdminTenants[0];
        console.log(`ðŸŽ¯ Auto-selecting first non-admin tenant: ${firstTenant.name} (${firstTenant.slug})`);
        selectTenant(firstTenant.slug);
      } else {
        console.log('âš ï¸ No non-admin tenants available for auto-selection');
      }
    }
  }, [tenants, tenant, tenantKeys, selectTenant]);

  /**
   * Manage global OpenAPI headers for tenant operations
   * CRITICAL: This only affects tenant operations, NOT the tenant list query
   */
  useEffect(() => {
    if (tenantApiKey) {
      OpenAPI.HEADERS = { 'X-API-Key': tenantApiKey };
      localStorage.setItem('tenantApiKey', tenantApiKey);
      console.log('ðŸ”‘ Set global headers with tenant API key');
    } else {
      OpenAPI.HEADERS = {};
      localStorage.removeItem('tenantApiKey');
      console.log('ðŸ”‘ Cleared global headers (no tenant selected)');
    }
    
    // Invalidate any tenant-specific queries when tenant API key changes
    queryClient.invalidateQueries({ queryKey: ['tenant-data'] });
  }, [tenantApiKey, queryClient]);

  return (
    <TenantContext.Provider value={{ 
      tenant, 
      tenants, 
      selectTenant, 
      tenantApiKey,  // Renamed from apiKey
      setTenantApiKey: handleSetTenantApiKey,  // Renamed from setApiKey
      isLoading, 
      tenantKeys 
    }}>
      {children}
    </TenantContext.Provider>
  );
};

/**
 * Hook to access tenant context
 * 
 * USAGE GUIDELINES:
 * - Use `tenantApiKey` for ALL tenant-specific operations (queries, mutations, etc.)
 * - Use `selectTenant(id)` to switch tenants - this automatically updates the tenant API key
 * - The tenant list loading is handled automatically with admin API key
 * - DO NOT manually manage admin vs tenant API keys - the context handles this
 * 
 * @returns TenantContextType with separated admin/tenant API key management
 */
export const useTenant = (): TenantContextType => {
  const context = useContext(TenantContext);
  if (!context) {
    throw new Error('useTenant must be used within a TenantProvider');
  }
  return context;
}; 