#!/usr/bin/env python3
"""
Demo Workflow Script - Complete Demo Setup and Testing

This script combines the demo tenant setup and testing workflow:
1. Sets up demo tenants 
2. Waits for user input to run tests
3. Runs comprehensive tests
4. If successful, waits for user input to restart frontend
5. Restarts frontend container

Usage:
    python scripts/workflow/demo_workflow.py --env development
    python scripts/workflow/demo_workflow.py --env test --auto-restart
"""

import argparse
import asyncio
import json
import os
import shutil
import subprocess
import sys
import time
from pathlib import Path
from typing import Dict, Any, Optional
import requests
import aiohttp
from dotenv import load_dotenv

# Add project root to Python path for imports
sys.path.insert(0, str(Path(__file__).parent.parent.parent))

try:
    from scripts.utils.project_paths import get_project_root
    PROJECT_ROOT = get_project_root()
except ImportError:
    # Fallback to old method
    SCRIPT_DIR = Path(__file__).parent.absolute()
    PROJECT_ROOT = SCRIPT_DIR.parent.parent

class DemoWorkflowManager:
    def __init__(self, environment: str = "development", auto_restart: bool = False, quiet: bool = False):
        self.environment = environment
        self.auto_restart = auto_restart
        self.quiet = quiet
        self.demo_keys_file = PROJECT_ROOT / "demo_tenant_keys.json"
        
    def log(self, message: str, level: str = "INFO"):
        """Log message unless in quiet mode."""
        if not self.quiet:
            print(message)
    
    def confirm(self, message: str, default: bool = False) -> bool:
        """Ask for user confirmation unless auto mode."""
        if self.auto_restart:
            self.log(f"Auto-mode: {message} â†’ {'Yes' if default else 'No'}")
            return default
        
        default_text = " (Y/n)" if default else " (y/N)"
        response = input(f"â“ {message}{default_text}: ").strip().lower()
        
        if not response:
            return default
        return response in ['y', 'yes']
    
    def run_command(self, cmd: list, description: str, cwd: Optional[Path] = None) -> tuple[bool, str]:
        """Run shell command and return success status and output."""
        try:
            self.log(f"Running: {description}")
            result = subprocess.run(
                cmd, 
                capture_output=True, 
                text=True, 
                cwd=cwd or PROJECT_ROOT
            )
            
            if result.returncode == 0:
                if not self.quiet and result.stdout:
                    print(f"  âœ… {result.stdout.strip()}")
                return True, result.stdout
            else:
                if not self.quiet and result.stderr:
                    print(f"  âŒ {result.stderr.strip()}")
                return False, result.stderr
                
        except Exception as e:
            self.log(f"Command failed: {e}", "ERROR")
            return False, str(e)
    
    def load_config(self) -> Dict[str, Any]:
        """Load configuration from .env file."""
        env_file = PROJECT_ROOT / ".env"
        load_dotenv(env_file)
        
        admin_tenant_id = os.getenv("ADMIN_TENANT_ID")
        admin_api_key = os.getenv("ADMIN_API_KEY") 
        backend_url = os.getenv("BACKEND_URL", "http://localhost:8000")
        
        if not admin_tenant_id or not admin_api_key:
            self.log("âŒ Missing admin credentials in .env file", "ERROR")
            self.log("   Required: ADMIN_TENANT_ID, ADMIN_API_KEY", "ERROR")
            self.log("   These should be auto-generated by the init container.", "ERROR")
            return None
        
        return {
            "admin_tenant_id": admin_tenant_id,
            "admin_api_key": admin_api_key,
            "backend_url": backend_url.rstrip("/")
        }

    def make_api_request(self, method: str, url: str, headers: Dict[str, str], data: Optional[Dict] = None, timeout: int = 60) -> tuple[bool, Any]:
        """Make HTTP API request with error handling."""
        try:
            if method.upper() == "GET":
                response = requests.get(url, headers=headers, timeout=timeout)
            elif method.upper() == "POST":
                response = requests.post(url, headers=headers, json=data, timeout=timeout)
            else:
                self.log(f"Unsupported HTTP method: {method}", "ERROR")
                return False, None
                
            response.raise_for_status()
            return True, response.json()
            
        except requests.exceptions.Timeout:
            self.log(f"API request timed out after {timeout} seconds", "ERROR")
            self.log(f"   URL: {url}", "ERROR")
            return False, None
        except requests.exceptions.RequestException as e:
            self.log(f"API request failed: {e}", "ERROR")
            if hasattr(e, 'response') and e.response is not None:
                try:
                    error_detail = e.response.json()
                    self.log(f"   Error details: {error_detail}", "ERROR")
                except:
                    self.log(f"   Response: {e.response.text}", "ERROR")
            return False, None

    def initialize_database_schema(self, config: Dict[str, Any]) -> bool:
        """Initialize database tables for target environment via API."""
        self.log(f"ğŸ—„ï¸ Initializing database schema for {self.environment} environment...")
        
        url = f"{config['backend_url']}/api/v1/admin/system/init-database?environment={self.environment}"
        headers = {"X-API-Key": config["admin_api_key"]}
        
        success, result = self.make_api_request("POST", url, headers)
        
        if success:
            self.log(f"âœ… {result['message']}")
            return True
        else:
            self.log("âŒ Database schema initialization failed", "ERROR")
            return False

    def create_tenant_via_api(self, config: Dict[str, Any], tenant_name: str, description: str) -> Optional[Dict[str, Any]]:
        """Create tenant via API with extended timeout for slow operations."""
        url = f"{config['backend_url']}/api/v1/admin/tenants"
        headers = {"X-API-Key": config["admin_api_key"]}
        data = {
            "name": tenant_name,
            "description": description,
            "auto_sync": False,  # Disabled to prevent automatic heavy operations
            "sync_interval": 60
        }
        
        success, result = self.make_api_request("POST", url, headers, data, timeout=120)
        return result if success else None

    def get_tenant_by_name(self, config: Dict[str, Any], tenant_name: str) -> Optional[Dict[str, Any]]:
        """Get tenant by name via API."""
        url = f"{config['backend_url']}/api/v1/admin/tenants"
        headers = {"X-API-Key": config["admin_api_key"]}
        
        success, data = self.make_api_request("GET", url, headers)
        
        if not success:
            return None
        
        # Extract tenants array from response wrapper
        tenants = data.get("tenants", [])
        
        # Find tenant by name
        for tenant in tenants:
            if tenant["name"] == tenant_name:
                return tenant
        return None

    def copy_demo_files(self, tenant_id: str, tenant_name: str) -> int:
        """Copy demo files from demo-data directory to tenant's directory."""
        demo_source_dir = PROJECT_ROOT / "demo-data" / tenant_name
        tenant_upload_dir = PROJECT_ROOT / "data" / "uploads" / tenant_id
        
        if not demo_source_dir.exists():
            return 0
            
        # Create tenant upload directory if it doesn't exist
        tenant_upload_dir.mkdir(parents=True, exist_ok=True)
        
        files_copied = 0
        for demo_file in demo_source_dir.glob("*"):
            if demo_file.is_file():
                dest_file = tenant_upload_dir / demo_file.name
                # Only copy if destination doesn't exist or is older
                if not dest_file.exists() or demo_file.stat().st_mtime > dest_file.stat().st_mtime:
                    shutil.copy2(demo_file, dest_file)
                    files_copied += 1
                    self.log(f"    * Copied: {demo_file.name}")
                else:
                    self.log(f"    * Skipped: {demo_file.name} (already exists)")
        
        return files_copied

    def save_api_keys(self, api_keys: Dict[str, str], tenant_data: Dict[str, Dict] = None) -> None:
        """Save API keys to JSON file using tenant IDs as keys."""
        keys_file = PROJECT_ROOT / "demo_tenant_keys.json"
        
        # Create structured format using tenant IDs
        tenant_keys = {}
        for tenant_name, api_key in api_keys.items():
            # Get tenant ID from tenant_data if available
            tenant_id = None
            if tenant_data and tenant_name in tenant_data:
                tenant_id = tenant_data[tenant_name].get("id")
            
            if tenant_id:
                tenant_keys[tenant_id] = {
                    "api_key": api_key,
                    "slug": tenant_name,
                    "description": f"Demo {tenant_name} with company documents ({self.environment})"
                }
            else:
                # Fallback to tenant name as key
                tenant_keys[tenant_name] = {
                    "api_key": api_key,
                    "slug": tenant_name,
                    "description": f"Demo {tenant_name} with company documents ({self.environment})"
                }
        
        try:
            with open(keys_file, 'w') as f:
                json.dump(tenant_keys, f, indent=2)
            self.log(f"âœ“ API keys saved to {keys_file}")
            
            # Also copy to frontend public directory if it exists
            frontend_public = PROJECT_ROOT / "src" / "frontend" / "public"
            if frontend_public.exists():
                frontend_keys_file = frontend_public / "demo_tenant_keys.json"
                shutil.copy2(keys_file, frontend_keys_file)
                self.log(f"âœ“ API keys copied to frontend: {frontend_keys_file}")
                
        except Exception as e:
            self.log(f"âœ— Failed to save API keys: {e}", "ERROR")

    def validate_backend_connection(self, config: Dict[str, Any]) -> bool:
        """Validate that the backend is accessible before starting setup."""
        try:
            self.log("ğŸ” Validating backend connection...")
            url = f"{config['backend_url']}/api/v1/health/liveness"
            response = requests.get(url, timeout=10)
            response.raise_for_status()
            self.log("âœ“ Backend is accessible")
            return True
        except Exception as e:
            self.log(f"âŒ Backend validation failed: {e}", "ERROR")
            self.log("   Make sure containers are running: docker-compose up -d", "ERROR")
            return False

    def setup_demo_tenants(self) -> bool:
        """Setup demo tenants using integrated API calls."""
        self.log("ğŸ—ï¸ Setting up demo tenants...")
        
        # Load configuration
        config = self.load_config()
        if not config:
            return False
        
        self.log(f"ğŸŒ Target Environment: {self.environment}")
        self.log(f"ğŸ–¥ï¸ Backend URL: {config['backend_url']}")
        
        # Validate backend connection
        if not self.validate_backend_connection(config):
            return False
        
        # Initialize database schema
        if not self.initialize_database_schema(config):
            return False
        
        # Setup demo tenants
        tenant_configs = [
            {"name": "tenant1", "description": f"Demo tenant 1 with company documents ({self.environment})"},
            {"name": "tenant2", "description": f"Demo tenant 2 with company documents ({self.environment})"},
            {"name": "tenant3", "description": f"Demo tenant 3 with company documents ({self.environment})"}
        ]
        
        api_keys = {}
        tenant_data = {}  # Store tenant ID and info for JSON file generation
        
        for config_item in tenant_configs:
            tenant_name = config_item["name"]
            self.log(f"\n--- Setting up {tenant_name} ---")
            
            try:
                # Check if tenant exists
                tenant = self.get_tenant_by_name(config, tenant_name)
                
                if not tenant:
                    # Create tenant via API
                    self.log(f"â³ Creating tenant {tenant_name}...")
                    tenant = self.create_tenant_via_api(config, tenant_name, config_item["description"])
                    if not tenant:
                        self.log(f"âŒ Failed to create tenant {tenant_name}", "ERROR")
                        api_keys[tenant_name] = "*** SETUP FAILED ***"
                        tenant_data[tenant_name] = {"id": "unknown", "name": tenant_name, "slug": tenant_name}
                        continue
                    self.log(f"âœ“ Created tenant: {tenant['name']}")
                    # New tenants get their own API key from creation
                    api_key = tenant.get("api_key", "")
                else:
                    self.log(f"âœ“ Found existing tenant: {tenant['name']}")
                    # For existing tenants, use admin API key (has access to all tenants)
                    self.log(f"â³ Using admin API key for existing tenant...")
                    api_key = config["admin_api_key"]
                    self.log(f"  âœ“ Admin API key provides access to all tenants")
                
                api_keys[tenant_name] = api_key
                tenant_data[tenant_name] = {
                    "id": tenant["id"],
                    "name": tenant["name"],
                    "slug": tenant.get("slug", tenant_name)
                }
                
                self.log(f"  - Tenant ID: {tenant['id']}")
                self.log(f"  - API Key: {api_key[:20]}..." if api_key and len(api_key) > 20 else f"  - API Key: {api_key}")
                
                # Copy demo files
                files_copied = self.copy_demo_files(tenant["id"], tenant_name)
                if files_copied > 0:
                    self.log(f"  - Demo files: {files_copied} files copied")
                else:
                    self.log(f"  - âš ï¸ No demo files found for {tenant_name}", "WARN")
                    
            except Exception as e:
                self.log(f"âŒ Failed to setup {tenant_name}: {e}", "ERROR")
                # Continue with other tenants instead of failing completely
                api_keys[tenant_name] = "*** SETUP FAILED ***"
                tenant_data[tenant_name] = {"id": "unknown", "name": tenant_name, "slug": tenant_name}
                continue
        
        # Check if any tenants succeeded
        failed_tenants = [name for name, key in api_keys.items() if "FAILED" in key]
        successful_tenants = [name for name, key in api_keys.items() if "FAILED" not in key]
        
        # Save API keys (only if we have some successful tenants)
        if successful_tenants:
            self.save_api_keys(api_keys, tenant_data)
            
            self.log("\n=== Demo Setup Complete! ===")
            self.log(f"âœ… Database schema initialized for {self.environment}")
            self.log(f"âœ… {len(successful_tenants)} demo tenants configured successfully")
            if failed_tenants:
                self.log(f"âš ï¸ {len(failed_tenants)} tenant(s) failed: {', '.join(failed_tenants)}", "WARN")
            self.log(f"âœ… API keys saved to demo_tenant_keys.json")
            
            # Store tenant data for testing
            self.tenant_keys = {}
            for tenant_name, api_key in api_keys.items():
                if "FAILED" not in api_key:
                    tenant_id = tenant_data[tenant_name]["id"]
                    self.tenant_keys[tenant_id] = {
                        "api_key": api_key,
                        "slug": tenant_name,
                        "description": f"Demo {tenant_name} with company documents ({self.environment})"
                    }
            
            return True
        else:
            self.log("âŒ Setup failed - no tenants were configured successfully", "ERROR")
            return False
    
    async def test_api_endpoint(self, session: aiohttp.ClientSession, method: str, 
                               endpoint: str, api_key: str, data: Dict = None) -> Dict[str, Any]:
        """Test a single API endpoint"""
        url = f"http://localhost:8000{endpoint}"
        headers = {"X-API-Key": api_key, "Content-Type": "application/json"}
        
        try:
            if method.upper() == "GET":
                async with session.get(url, headers=headers) as response:
                    result = await response.json()
                    return {"status": response.status, "data": result}
            elif method.upper() == "POST":
                async with session.post(url, headers=headers, json=data) as response:
                    result = await response.json()
                    return {"status": response.status, "data": result}
        except Exception as e:
            return {"status": "error", "error": str(e)}
    
    async def test_admin_access(self, session: aiohttp.ClientSession, admin_key: str) -> bool:
        """Test admin API access"""
        self.log("\n=== Testing Admin Access ===")
        
        if not admin_key:
            self.log("âŒ Admin API key not found in .env", "ERROR")
            return False
        
        # Test admin tenant list
        result = await self.test_api_endpoint(session, "GET", "/api/v1/auth/tenants", admin_key)
        
        if result["status"] == 200:
            tenants = result["data"]
            self.log(f"âœ… Admin access working - Found {len(tenants)} tenants")
            for tenant in tenants:
                self.log(f"   - {tenant['name']} ({tenant['slug']})")
            return True
        else:
            self.log(f"âŒ Admin access failed: {result}", "ERROR")
            return False
    
    async def test_tenant_access(self, session: aiohttp.ClientSession, 
                                tenant_name: str, tenant_info: Dict) -> bool:
        """Test individual tenant access"""
        self.log(f"\n=== Testing {tenant_name} ===")
        api_key = tenant_info["api_key"]
        slug = tenant_info["slug"]
        
        # Test tenant authentication
        auth_result = await self.test_api_endpoint(session, "GET", "/api/v1/auth/tenant", api_key)
        
        if auth_result["status"] != 200:
            self.log(f"âŒ {tenant_name} authentication failed: {auth_result}", "ERROR")
            return False
        
        tenant_data = auth_result["data"]
        self.log(f"âœ… {tenant_name} authenticated successfully")
        self.log(f"   - Tenant ID: {tenant_data.get('id', 'N/A')}")
        self.log(f"   - Plan: {tenant_data.get('plan_tier', 'N/A')}")
        
        # Test file listing
        files_result = await self.test_api_endpoint(session, "GET", "/api/v1/files", api_key)
        
        if files_result["status"] == 200:
            files = files_result["data"]
            if isinstance(files, list):
                self.log(f"âœ… File listing working - Found {len(files)} files")  
                if len(files) > 0:
                    self.log("   Files:")
                    for file in files[:3]:  # Show first 3 files
                        self.log(f"     - {file.get('filename', 'N/A')} ({file.get('file_size', 0)} bytes)")
            else:
                self.log(f"âœ… File listing working - Response: {files}")
        else:
            self.log(f"âš ï¸ File listing failed: {files_result}", "WARN")
        
        # Test health check  
        health_result = await self.test_api_endpoint(session, "GET", "/api/v1/health/liveness", api_key)
        
        if health_result["status"] == 200:
            health = health_result["data"]
            self.log(f"âœ… Health check passed - Status: {health.get('status', 'unknown')}")
            
            # Show service status
            services = health.get('services', {})
            for service, status in services.items():
                icon = "âœ…" if status == "healthy" else "âš ï¸"
                self.log(f"   {icon} {service}: {status}")
        else:
            self.log(f"âš ï¸ Health check failed: {health_result}", "WARN")
        
        return True
    
    async def test_rag_query(self, session: aiohttp.ClientSession) -> bool:
        """Test RAG query functionality with first tenant"""
        self.log("\n=== Testing RAG Query ===")
        
        # Use first tenant for RAG testing
        if not hasattr(self, 'tenant_keys') or not self.tenant_keys:
            self.log("âŒ No tenant keys available for RAG testing", "ERROR")
            return False
            
        first_tenant = list(self.tenant_keys.items())[0]
        tenant_id, tenant_info = first_tenant
        api_key = tenant_info["api_key"]
        
        # Test RAG query with simple query
        query_data = {
            "query": "What is our company mission?"
        }
        
        rag_result = await self.test_api_endpoint(session, "POST", "/api/v1/query", api_key, query_data)
        
        if rag_result["status"] == 200:
            response = rag_result["data"]
            self.log(f"âœ… RAG query successful")
            self.log(f"   Query: {query_data['query']}")
            self.log(f"   Answer: {response.get('answer', 'No answer')[:100]}...")
            
            sources = response.get('sources', [])
            self.log(f"   Sources: {len(sources)} documents")
            for source in sources[:2]:
                self.log(f"     - {source.get('filename', 'Unknown')} (score: {source.get('score', 0):.2f})")
            
            return True
        else:
            self.log(f"âš ï¸ RAG query failed: {rag_result}", "WARN")
            return False
    
    async def run_tests(self) -> bool:
        """Run comprehensive demo tenant tests."""
        self.log("ğŸ§ª Running demo tenant tests...")
        
        # Load admin key
        config = self.load_config()
        if not config:
            return False
            
        admin_key = config["admin_api_key"]
        
        # Load tenant keys if available
        if not hasattr(self, 'tenant_keys'):
            if self.demo_keys_file.exists():
                try:
                    with open(self.demo_keys_file) as f:
                        self.tenant_keys = json.load(f)
                except Exception as e:
                    self.log(f"âŒ Could not load tenant keys: {e}", "ERROR")
                    return False
            else:
                self.log("âŒ Demo tenant keys file not found", "ERROR")
                return False
        
        async with aiohttp.ClientSession() as session:
            success = True
            
            # Test admin access
            admin_success = await self.test_admin_access(session, admin_key)
            success = success and admin_success
            
            # Test each tenant
            for tenant_id, tenant_info in self.tenant_keys.items():
                tenant_success = await self.test_tenant_access(session, tenant_info["slug"], tenant_info) 
                success = success and tenant_success
            
            # Test RAG functionality
            # rag_success = await self.test_rag_query(session)
            # success = success and rag_success
            
            # Summary
            self.log("\n" + "=" * 50)
            if success:
                self.log("ğŸ‰ All tests passed!")
                self.log("âœ… Demo tenants are working correctly")
                self.log("\nğŸ“ Next steps:")
                self.log("1. Upload documents: POST /api/v1/files/upload")
                self.log("2. Trigger sync: POST /api/v1/sync/trigger") 
                self.log("3. Query documents: POST /api/v1/query")
            else:
                self.log("âŒ Some tests failed")
                self.log("âš ï¸ Check the backend logs for more details")
            
            return success
    
    def restart_frontend(self) -> bool:
        """Restart the frontend container."""
        self.log("ğŸ”„ Restarting frontend container...")
        
        success, output = self.run_command(
            ["docker-compose", "restart", "frontend"],
            "Restarting frontend container"
        )
        
        if success:
            self.log("âœ… Frontend container restarted successfully!")
            self.log("ğŸŒ Frontend should be available at http://localhost:3000")
            return True
        else:
            self.log(f"âŒ Frontend restart failed: {output}", "ERROR")
            return False
    
    def check_prerequisites(self) -> bool:
        """Check if prerequisites are met."""
        self.log("ğŸ” Checking prerequisites...")
        
        # Check if backend is running
        success, _ = self.run_command(
            ["docker-compose", "ps", "backend"],
            "Checking backend container status"
        )
        
        if not success:
            self.log("âŒ Backend container is not running. Please start with: docker-compose up -d", "ERROR")
            return False
        
        # Check if .env file exists
        env_file = PROJECT_ROOT / ".env"
        if not env_file.exists():
            self.log("âŒ .env file not found. Please copy from .env.example", "ERROR")
            return False
        
        self.log("âœ… Prerequisites check passed!")
        return True
    
    def run_workflow(self) -> bool:
        """Run the complete demo workflow."""
        self.log("ğŸš€ Starting Demo Workflow")
        self.log("=" * 50)
        
        # Step 1: Check prerequisites
        if not self.check_prerequisites():
            return False
        
        # Step 2: Setup demo tenants
        if not self.setup_demo_tenants():
            return False
        
        # Step 3: Wait for user input to run tests
        if not self.confirm("Run demo tenant tests now?", default=True):
            self.log("Tests skipped by user")
            return True
        
        # Step 4: Run tests
        test_success = asyncio.run(self.run_tests())
        if not test_success:
            self.log("âŒ Tests failed - workflow stopped", "ERROR")
            return False
        
        # Step 5: Wait for user input to restart frontend
        if not self.confirm("Restart frontend container now?", default=True):
            self.log("Frontend restart skipped by user")
            self.log("ğŸ‰ Demo workflow completed successfully!")
            return True
        
        # Step 6: Restart frontend
        if not self.restart_frontend():
            self.log("âš ï¸ Frontend restart failed, but workflow otherwise successful", "WARN")
            return True
        
        self.log("ğŸ‰ Complete demo workflow finished successfully!")
        self.log("ğŸ’¡ You can now test the frontend at http://localhost:3000")
        
        return True

def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(description='Demo Workflow - Setup, Test, and Deploy')
    parser.add_argument('--env', choices=['development', 'staging', 'test', 'production'],
                       default='development', help='Environment to setup (default: development)')
    parser.add_argument('--auto-restart', action='store_true', 
                       help='Automatically restart frontend without prompting')
    parser.add_argument('--quiet', action='store_true', help='Minimal output')
    
    args = parser.parse_args()
    
    # Create workflow manager
    manager = DemoWorkflowManager(
        environment=args.env,
        auto_restart=args.auto_restart,
        quiet=args.quiet
    )
    
    try:
        success = manager.run_workflow()
        sys.exit(0 if success else 1)
        
    except KeyboardInterrupt:
        manager.log("\nWorkflow interrupted by user")
        sys.exit(1)
    except Exception as e:
        manager.log(f"Unexpected error: {e}", "ERROR")
        sys.exit(1)

if __name__ == "__main__":
    main()